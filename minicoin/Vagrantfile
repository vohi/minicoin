# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2.4"

require 'yaml'
require 'json'
require 'net/http'

require_relative "lib/local_command.rb"
require_relative "lib/expand_env.rb"
require_relative "lib/loader.rb"
require_relative "lib/roles.rb"
require_relative "lib/sharing.rb"
require_relative "lib/virtualbox.rb"
require_relative "lib/vmware_desktop.rb"
require_relative "lib/azure.rb"

$is_windows_host = !(ENV["windir"].nil?)
$has_winrm = false
$HOME = ENV["HOME"]
$USER = ENV['USER']
if $is_windows_host
  $HOME = ENV["USERPROFILE"]
  $USER = ENV['USERNAME']
end

$PWD = File.dirname(__FILE__)

$REQUESTED_BOXES = []

for a in 1 ... ARGV.length
  arg = ARGV[a]
  if arg.start_with?("-")
    next
  end
  $REQUESTED_BOXES << ARGV[a]
end

Vagrant.configure("2") do |config|
  config.vagrant.sensitive = [ ENV["minicoin_key"] ]
  machines = load_minicoin()
  if ARGV[0] == "list"
    puts "Available machines are:"
    puts
  end

  machine_index = 0
  machines.each do |machine|
    name = machine["name"]
    # Give each defined machine a well-defined port number for ssh forwarding.
    # If we don't do that, then the port of a suspended or halted machine might
    # be re-used by vagrant, and then resuming the suspended machine will fail,
    # or result in traffic going the wrong way (ie with mutagen synching).
    machine["index"] = machine_index
    machine_index = machine_index + 1
    if name.nil?
      puts "==> Machine without name: #{machine}"
      next
    end
    unless $REQUESTED_BOXES.empty?
      requested = false
      for requested_box in $REQUESTED_BOXES
        if requested_box.start_with?("/") && requested_box.end_with?("/")
          requested = name =~ /#{requested_box[1..requested_box.length - 2]}/
        elsif requested_box == name
          requested = true
        end
        break if requested
      end
      if !requested
        next
      end
    end
    machine_box = machine["box"]
    machine_url = machine_box
    if !machine_box.nil?
      if machine_box.include?("$minicoin_key")
        minicoin_key = ENV['minicoin_key']
        if minicoin_key.nil?
          if ["validate"].include? ARGV[0]
            puts "==> #{name}: Box is private, but key is not set. Set 'minicoin_key' environment variable!"
          end
          next
        end
        machine_url = machine_url.gsub("$minicoin_key", minicoin_key)
        machine_box = machine_box.gsub("$minicoin_key/", "")
      end
      machine_box = expand_env(machine_box, nil)
    end
    if machine_box.nil?
      puts "==> #{name}: Machine has no box set"
      next
    end


    if ARGV[0] == "list"
      puts "#{name.ljust(25)} #{machine_box}"
      next
    end

    config.vm.define name, autostart: false do |box|
      if !machine["provider"].nil?
        box.vm.provider machine["provider"]
      end
  
      if machine["os"].nil?
        is_windows = ((name =~ /windows/i) || (machine_box =~ /windows/i)) != nil
        is_mac = ((name =~ /mac/i) || (machine_box =~ /mac/i)) != nil
      else
        is_windows = (machine["os"] =~ /windows/i) != nil
        is_mac = (machine['os'] =~ /macos/i) != nil
      end

      sources = $urls[machine_box.split(/\//).first]
      unless sources.nil?
        box.vm.box_url = []
        if sources.is_a?(String)
          sources = [sources];
        end
        if File.file?("boxes/#{machine_box}.json")
          box.vm.box_url = ["#{sources[0]}/#{machine_url}.json"]
        else
          sources.each do |source|
            box.vm.box_url += ["#{source}/#{machine_url}.box"]
          end
        end
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?

      # Platform specific configurations
      if is_windows
        machine["os"] = "windows"
        box.vm.guest = :windows
        box.vm.hostname = name[0..14] # windows hostnames cannot be more than 15 characters long
        ENV["GUEST_HOMES"] = "C:\\Users"

        # "Intel Pro/1000 MT Desktop" must be used on Windows
        machine["nictype1"] = "82540EM"

        # default to rdp forwarding, unless ports are set
        machine["ports"] = [ { "id" => "rdp" } ] if machine["ports"].nil?

        # Test if winrm is available
        begin
          $has_winrm = require 'winrm' unless $has_winrm
        rescue LoadError => e
          if ARGV[0] != "info"
            puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          end
        end

        if $has_winrm
          box.vm.communicator = :winrm
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        machine["os"] = "macos"
        box.vm.guest = :darwin
        ENV["GUEST_HOMES"] = "/Users"

        # "Intel Pro/1000 MT Server" must be used on Mac
        machine["nictype1"] = "82545EM"
      else
        if machine["os"].nil?
          machine["os"] = "linux"
        else
          box.vm.guest = machine["os"]
        end
        ENV["GUEST_HOMES"] = "/home"
        # rely on defaults and vagrant autodetection for nix'es
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end
      if machine["basebox"] == true
        box.ssh.insert_key = false
      end
      config.ssh.shell = machine["shell"] unless machine["shell"].nil?

      if ARGV[0] == "info"
        puts "#{name} #{machine['os']} #{box.vm.communicator} #{ENV['GUEST_HOMES']} #{ENV["HOME_SHARE"]}"
        next
      end

      # port forwarding
      box.vm.network "forwarded_port", id: "ssh", # id must be ssh
        guest: 22,
        host: 2200 + machine["index"],
        auto_correct: true
      ports = machine["ports"]
      if !ports.nil?
        begin
          ports.each do |port|
            attributes = {
              :auto_correct => true
            }
            port.each do |key, value|
              attributes[key.to_sym] = value
            end
            raise "No ID" if attributes[:id].nil?
            if attributes[:guest].nil?
              case attributes[:id]
              when "rdp"
                attributes[:guest] = 3389
              else
                raise "No guest port"
              end
            end
            if attributes[:id] == "rdp"
              # turn on local hypervisor's RDP server, if supported
              machine["rdp"] = true
            end
            attributes[:host] = attributes[:guest] * 10 + machine["index"] if attributes[:host].nil?
            box.vm.network "forwarded_port", attributes
          end
        rescue
          puts "==> #{name}: 'ports' needs to be a list of mappings, and 'id' and 'guest' needs to be set"
        end
      end

      # private network setup
      box.vm.hostname = name
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
        machine["nictype2"] = machine["nictype1"] if machine["nictype2"].nil?
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
        machine["nictype2"] = machine["nictype1"] if machine["nictype2"].nil?
      end

      # map virtual machine configurations to provider specific settings
      begin
        virtualbox_setup(box, machine)
        vmware_setup(box, machine)
        azure_setup(box, machine)
      rescue => e
        puts "==> #{name}: Error initializing provider specific settings:"
        puts "             #{e}"
      end

      # folder sharing, taking guest OS and provider specific quirks into account
      default_shares = $settings["defaults"]["shared_folders"]
      default_shares = [default_shares] unless default_shares.kind_of?(Array)
      machine_shares = machine["shared_folders"]
      machine_shares = [machine_shares]  unless machine_shares.kind_of?(Array)
      shares = default_shares + machine_shares

      if shares.include?("disabled")
        box.vm.synced_folder ".", "/minicoin", disabled: true
      else
        share_folders(box, machine, shares)
      end

      # Definition of provisioning steps
      default_roles = $settings["defaults"]["roles"]
      default_roles = [default_roles] unless default_roles.kind_of?(Array)

      machine_roles = machine["roles"]
      machine_roles = [machine_roles] unless machine_roles.kind_of?(Array)

      # add_role modifies, so make a deep copy of default_roles
      roles = Marshal.load(Marshal.dump(default_roles))
      roles.concat(machine_roles)
      machine["roles"] = roles
      roles.each do |role|
        begin
          add_role(box, role, name) unless role.nil?
        rescue => e
          puts "==> #{name}: Error when adding role #{role}:"
          puts "             #{e}"
        end
      end

      if ARGV[0] == "provision"
        begin
          install_string = ARGV[ARGV.index("--provision-with") + 1]
          if install_string.start_with?("install:")
            packages = install_string["install:".length..-1].split(",")
            packages.each do |package|
              role = {
                "role" => "install",
                "packages" => package
              }
              add_role(box, role, name)
            end
          end
        rescue
        end
      end

      if ARGV[0] == "describe"
        puts machine.to_yaml
        next
      end

      # make powershell the default ssh shell on Windows at the end, as some provisioners rely on cmd
      if box.vm.guest == :windows
        box.vm.provision "powershell_default",
          type: :shell,
          inline: "New-ItemProperty -Path \"HKLM:\\SOFTWARE\\OpenSSH\" -Name DefaultShell -Value \"C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\" -PropertyType String -Force | Out-Null"
      end
    end
  end
end
