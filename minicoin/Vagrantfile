# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2.4"

# Import YAML
require 'yaml'
require 'net/http'

$is_windows_host = !(ENV["windir"].nil?)
$HOME = ENV["HOME"]
$USER = ENV['USER']
if $is_windows_host
  $HOME = ENV["USERPROFILE"]
  $USER = ENV['USERNAME']
end

$PWD = File.dirname(__FILE__)

def merge_yaml(first, second)
  if first.nil? && second.nil?
    nil
  elsif first.nil?
    second
  elsif second.nil?
    first
  elsif first.is_a?(Hash) && second.is_a?(Hash)
    first.merge!(second) do |key, one, two|
      merge_yaml(one, two)
    end
  elsif first.is_a?(Array)
    if second.is_a?(Array)
      second.each do |s|
        first << s
      end
      first
    else
      first << second
    end
  elsif second.is_a?(Array)
    second << first
  else # two values - make an array
    [first, second]
  end
end

def load_settings(yaml, user_yaml)
  # a hash
  $settings = yaml["settings"]
  $settings = {} if $settings.nil?
  $settings["home_share"] = $HOME if $settings["home_share"].nil?

  user_settings = user_yaml["settings"] unless user_yaml.nil?
  $settings = merge_yaml($settings, user_settings)

  $settings["home_share"] = $settings["home_share"].gsub("$HOME", $HOME)
  $settings["home_share"] = $settings["home_share"].gsub("~", $HOME)
end

def load_urls(yaml, user_yaml)
  # a hash of arrays
  $urls = yaml["urls"]
  user_urls = user_yaml["urls"] unless user_yaml.nil?

  $urls = merge_yaml($urls, user_urls)
end

def load_boxes(yaml, user_yaml)
  machines = yaml["machines"]

  user_machines = user_yaml["machines"] unless user_yaml.nil?
  user_machines = [] if user_machines.nil?
  user_machines.each do |user_machine|
    idx = machines.find_index {|m| m["name"] == user_machine["name"] }
    if !idx.nil?
      machines[idx].each do |key, value|
        if !user_machine[key].nil?
          machines[idx][key] = user_machine[key]
        end
      end
    else
      machines << user_machine
    end
  end

  return machines
end

def load_includes(yaml, basedir)
  includes = yaml["includes"] unless yaml.nil?

  unless includes.nil?
    includes.each do |include|
      include_file = File.join(basedir, include)
      begin
        include_yaml = YAML.load_file(include_file)
        include_yaml = load_includes(include_yaml, File.dirname(include_file))
        include_yaml.each do |section, data|
          yaml[section] = merge_yaml(yaml[section], data) unless section == "includes"
        end
      rescue => error
        puts "Error loading file #{include_file}: #{error}"
      end
    end
  end

  return yaml
end

def load_minicoin()
  global_file = File.join($PWD, 'boxes.yml')
  yaml = YAML.load_file(global_file)

  user_file = File.join($HOME, 'minicoin/boxes.yml')
  user_yaml = nil
  if File.file?(user_file)
    user_yaml = YAML.load_file(user_file)
  end

  yaml = load_includes(yaml, $PWD)
  user_yaml = load_includes(user_yaml, $HOME)

  machines = load_boxes(yaml, user_yaml)
  load_settings(yaml, user_yaml)
  load_urls(yaml, user_yaml)

  return machines
end

def fetch_file(uri, local)
  begin
    downloader = Vagrant::Util::Downloader.new(uri, local)
    downloader.download!
  rescue => error
    puts "Error downloading #{uri}: #{error}"
    return false
  end
end

def insert_disk(box, disk_filename, role_params)
  disk_data = YAML.load_file(disk_filename)
  disk_file = disk_data["file"]
  disk_archive = disk_data["archive"]
  disk_urls = disk_data["urls"]
  if disk_urls.is_a?(String)
    disk_urls = [disk_urls]
  end
  disk_urls = [] if disk_urls.nil?
  disk_urls += $urls["disks"] unless $urls["disks"].nil?

  if disk_archive.nil?
    disk_archive = disk_file
  end

  disk_cache = "#{$PWD}/.diskcache"
  if ["up", "provision", "reload"].include? ARGV[0]
    Dir.mkdir(disk_cache) unless Dir.exist?(disk_cache)

    if !File.file?("#{disk_cache}/#{disk_file}")
      if !File.file?("#{disk_cache}/#{disk_archive}")
        disk_urls.each do |server|
          url = URI("#{server}/disks/#{disk_archive}")
          puts "Downloading '#{url}'..."
          if fetch_file(url, "#{disk_cache}/#{disk_archive}")
            break
          end
        end
      end
      if !File.file?("#{disk_cache}/#{disk_archive}")
        puts "Failed to download '#{disk_archive}' from any of #{disk_urls}"
      else
        puts "Extracting '#{disk_archive}'"
        begin
          require 'zip'
          Zip::File.open("#{disk_cache}/#{disk_archive}") do |zipfile|
            zipfile.extract("#{disk_file}", "#{disk_cache}/#{disk_file}")
          end
        end
      end
    end
    if !File.file?("#{disk_cache}/#{disk_file}")
      puts "==> Disk file '#{disk_file}' not available"
      return false
    end

    disk_settings = disk_data["settings"] unless disk_data.nil?
    if disk_settings.nil?
      disk_settings = {}
    end
    # default settings, disks can override
    disk_settings["storagectl"] = "SATA" unless !disk_settings["storagectl"].nil?

    if disk_file.end_with?(".iso")
      disk_settings["port"] = "1" unless !disk_settings["port"].nil?
      disk_settings["type"] = "dvddrive" unless !disk_settings["type"].nil?
    elsif disk_file.end_with?(".vdi") || disk_file.end_with?(".vmdk")
      disk_settings["port"] = "2" unless !disk_settings["port"].nil?
      disk_settings["type"] = "hdd" unless !disk_settings["type"].nil?
      disk_settings["mtype"] = "multiattach" unless !disk_settings["mtype"].nil?
    end

    # boxes can override disk settings
    if role_params.is_a?(Hash)
      role_params.each do |key, value|
        disk_settings[key] = value
      end
    end

    box.vm.provider :virtualbox do |vb|
      storage_params = [
        "storageattach", :id,
        "--medium", "#{disk_cache}/#{disk_file}",
      ]

      disk_settings.each do |key, value|
        storage_params += ["--#{key}", "#{value}"]
      end
      vb.customize storage_params
    end
    box.vm.provider :vmware_desktop do |vmware|
      # map defaults to VMWare
      device_ctl = "sata0:" if disk_settings["storagectl"] == "SATA"
      device_ctl = "ide0:" if disk_settings["storagectrl"] == "IDE"
      device_port = disk_settings["port"]

      device_string = "#{device_ctl}#{device_port}"
      puts "Inserting disk in #{device_string}"
      if disk_settings["type"] == "dvddrive"
        device_type = "cdrom-image"
      elsif disk_settings["type"] == "hdd"
        device_type = "disk"
      end

      vmware.vmx["#{device_string}.present"] = "TRUE"
      vmware.vmx["#{device_string}.deviceType"] = device_type
      vmware.vmx["#{device_string}.filename"] = "#{disk_cache}/#{disk_file}"
      vmware.vmx["#{device_string}.startConnected"] = "TRUE"
    end
  end
  return true
end

# expand environment variables in parameters
# and adjust any occurence of $HOME to the home on the guest
def expand_env(value, box)
  while (matches = value.match(/\$([A-Za-z0-9_]*)/))
    env_name = matches[1]
    if env_name == ""
      break
    end
    env_val = ENV[env_name]
    if env_val.nil?
      return nil
    else
      host_home = $settings["home_share"]
      if env_val.start_with?(host_home)
        if box.vm.guest == :windows
          env_val = env_val.sub(host_home, "C:\\\\Users\\\\host")
        elsif box.vm.guest == :darwin
          env_val = env_val.sub(host_home, "/Users/host")
        else
          env_val = env_val.sub(host_home, "/home/host")
        end
      end
      value = value.sub("$#{env_name}", env_val)
      if !box.nil? && box.vm.guest == :windows
        value = value.gsub("/", "\\\\")
      end
    end
  end
  return value
end

def add_role(box, role, name)
  role_params = role
  if role.is_a?(Hash) # parameterized role
    if !role["docker"].nil?
      role_params["name"] = role["docker"]
      role = "docker"
    else
      role = role["role"]
      role_params.delete("role")
    end
    role_params.each do |key, value|
      if value.nil?
        next
      end
      if value.is_a?(String)
        new_value = expand_env(value, box)
        if new_value.nil?
          puts "==> #{name}: Unexpanded environment variable in '#{value}' - skipping role '#{role}'"
          return
        end
        role_params[key] = new_value
      elsif value.is_a?(Array)
        array = []
        value.each do |entry|
          new_entry = expand_env(entry, box)
          if new_entry.nil?
            puts "==> #{name}: Unexpanded environment variable in '#{entry}' - skipping role '#{role}'"
            return
          end
          array << new_entry
        end
        role_params[key] = array
      end
    end
  end

  # user can add or override roles
  role_path = File.join($HOME, "minicoin/roles/#{role}")
  if !File.exist?(role_path)
    role_path = "#{$PWD}/roles/#{role}"
  end
  activity = false
  if File.file?("#{role_path}/playbook.yml")
    box.vm.provision "ansible" do |ansible|
      ansible.playbook = "#{role_path}/playbook.yml"
      ansible.become = true unless box.vm.guest == :windows
    end
    activity = true
  elsif File.file?("#{role_path}/disk.yml")
    activity = true
    if !insert_disk(box, "#{role_path}/disk.yml", role_params)
      puts "==> #{name}: Attaching disk failed for role '#{role}'"
    end
  elsif File.file?("#{role_path}/Dockerfile")
    docker_args = "--rm"
    role_params.each do |param, value|
      if value.nil?
        docker_args += " --#{param}"
      elsif value.is_a?(Array)
        value.each do |entry|
          docker_args += " --#{param} \"#{entry}\""
        end
      else
        docker_args += " --#{param} \"#{value}\""
      end
    end
    box.vm.provision "file",
      source: "#{role_path}/Dockerfile",
      destination: "#{role}/Dockerfile"
    box.vm.provision "docker" do |docker|
      docker.build_image "#{role}", args: docker_args
    end
    activity = true
  elsif role == "docker"
    detach = true
    restart = "always"

    name = role_params["docker"]
    image = role_params["image"]
    cmd = role_params["cmd"]
    args = role_params["args"]
    detach = (role_params["detach"] == true) unless role_params["detach"].nil?
    restart = role_params["restart"] unless role_params["restart"].nil?
    box.vm.provision "docker" do |docker|
      docker.run name,
      image: image,
      cmd: cmd,
      auto_assign_name: false,
      args: args,
      daemonize: detach,
      restart: restart
    end
    activity = true
  end

  # always check for a provisioning script
  script_ext = ".sh"
  upload_path = "/tmp/vagrant-shell/"
  if box.vm.guest == :windows
    script_ext = ".cmd"
    if File.file?("#{role_path}/provision.ps1")
      script_ext = ".ps1"
    end
    upload_path = "c:\\Windows\\temp\\"
  end
  upload_path += "provision_#{role}#{script_ext}"
  provisioning_file = "#{role_path}/provision#{script_ext}"
  if File.file?(provisioning_file)
    activity = true
    script_args = [role, name, $USER]
    if role_params.is_a?(Hash)
      role_params.each do |key, param|
        array=param
        if !param.is_a?(Array)
          array=[]
          array << param
        end
        array.each do |value|
          script_args += ["--#{key}"]
          script_args += ["#{value}"] unless value.nil?
        end
      end
    end
    box.vm.provision "shell", name: "#{role}", path: "#{provisioning_file}",
      args: script_args,
      upload_path: upload_path,
      privileged: true
  end

  if ! activity
    puts "==> #{role}: Provisioning script at '#{provisioning_file}' not found!"
  else
    # check for pre-/post-provisioning script to run locally
    if File.file?("#{role_path}/pre-provision.sh")
      box.trigger.before [:up, :provision] do |trigger|
        trigger.name = "before #{role}"
        trigger.run = {
          path: "#{role_path}/pre-provision.sh",
          args: name
        }
      end
    end

    if File.file?("#{role_path}/post-provision.sh")
      box.trigger.after [:up, :provision] do |trigger|
        trigger.name = "after #{role}"
        trigger.run = {
          path: "#{role_path}/post-provision.sh",
          args: name
        }
      end
    end
  end
end

def mac_share_folder(box, host_path, guest_path)
  guest_base = guest_path.split('/').last

  if $is_windows_host
    host_path = "/#{host_path}".gsub("\\", "/")
  end

  sshfs_options = \
    "reconnect,allow_other,defer_permissions,cache=no," \
    "IdentityFile=~/.ssh/#{$USER},StrictHostKeyChecking=no," \
    "volname=#{guest_base}"
  ssh_cmd = \
    "HOST_IP=$(echo $SSH_CONNECTION | cut -f 1 -d ' ') && " \
    "sshfs -o #{sshfs_options} #{$USER}@$HOST_IP"

  mount_point = "/tmp/vagrant-#{guest_base}"
  upload_path = "/tmp/vagrant-shell/#{guest_base}_mount"
  mount_command = {
    privileged: false,
    upload_path: "#{upload_path}.sh",
    inline: \
    "if [[ ! -d #{mount_point} ]]; then " \
    "  mkdir #{mount_point}; " \
    "fi && "\
    "if ! (mount | grep #{mount_point} > /dev/null); then " \
    "  #{ssh_cmd}:#{host_path} #{mount_point}; " \
    "fi && " \
    "if [[ ! -d #{guest_path} ]]; then " \
    "  sudo ln -fs #{mount_point} #{guest_path}; " \
    "fi || true"
  }
  box.vm.provision "shell", mount_command
  box.trigger.after [:up, :reload] do |trigger|
    trigger.name = "Mounting shared folder #{host_path}"
    trigger.run_remote = mount_command
  end
end

  # VirtualBox specific settings
def virtualbox_setup(box, machine)
  box.vm.provider :virtualbox do |vb|
    vb.memory = machine["memory"] unless machine["memory"].nil?
    vb.cpus = machine["cpus"] unless machine["cpus"].nil?
    vb.gui = machine["gui"] unless machine["gui"].nil?
    vb.customize ["modifyvm", :id, "--vram", machine["vram"]] unless machine["vram"].nil?
    vb.name = machine["name"]

    modifyvm = {}
    modifyvm["--clipboard"] = "bidirectional"
    modifyvm["--vram"] = machine["vram"] unless machine["vram"].nil?
    modifyvm["--nictype1"] = machine["nictype1"] unless machine["nictype1"].nil?
    modifyvm["--vrde"] = "on" unless machine["rdp_port"].nil?
    modifyvm["--vrdeport"] = machine["rdp_port"] unless machine["rdp_port"].nil?

    extradata = {}

    if !machine["resolution"].nil?
      resolution_map = {
        "VGA" => "640x480",
        "SVGA" => "800x600",
        "XGA" => "1024x768",
        "XGA+" => "1152x864",
        "HD" => "1280x720",
        "WXGA" => "1280x800",
        "SXGA" => "1280x1024",
        "SXGA+" => "1400x1050",
        "WXGA+" => "1440x900",
        "HD+" => "1600x900",
        "UXGA" => "1600x1200",
        "WSXGA+" => "1680x1050",
        "Full HD" => "1920x1080",
        "WUXGA" => "1920x1200",
        "DCI 2K" => "2048x1080",
        "Full HD+" => "2160x1440",
        "2304x1440" => "2304x1440", # unnamed
        "QHD" => "2560x1440",
        "WQXGA" => "2560x1600",
        "QWXGA+" => "2880x1800",
        "QHD+" => "3200x1800",
        "WQSXGA" => "3200x2048",
        "4K UHD" => "3840x2160",
        "WQUXGA" => "3840x2400",
        "DCI 4K" => "4096x2160",
        "HXGA" => "4096x3072",
        "UHD+" => "5120x2880",
        "WHXGA" => "5120x3200",
        "WHSXGA" => "6400x4096",
        "HUXGA" => "6400x4800",
        "8K UHD2" => "7680x4320"
      }
      res_name = machine["resolution"]
      resolution = resolution_map[res_name];
      if resolution.nil?
        puts "==> #{name}: Using custom display resolution #{res_name}"
        resolution = res_name;
      end
      extradata["CustomVideoMode1"] = "#{resolution}x32"
      extradata["VBoxInternal2/EfiGraphicsResolution"] = "#{resolution}"
    end
    extradata["GUI/ScaleFactor"] = machine["guiscale"] unless machine["guiscale"].nil?

    modifyvm.each do |key, value|
      vb.customize [
        "modifyvm", :id,
        key, value
      ]
    end
    extradata.each do |key, value|
      vb.customize [
        "setextradata", :id,
        key, value
      ]
    end
  end
end

def vmware_setup(box, machine)
  box.vm.provider :vmware_desktop do |vmware|
    vmware.gui = machine["gui"] unless machine["gui"].nil?
    vmware.vmx["memsize"] = machine["memory"] unless machine["memory"].nil?
    vmware.vmx["numvcpus"] = machine["cpus"] unless machine["cpus"].nil?
    vmware.vmx["svga.vramSize"] = machine["vram"] unless machine["vram"].nil?
    vmware.vmx["vmx.allowNested"] = "TRUE"
    vmware.vmx["vhv.enable"] = "TRUE"
  end
end

def win_link_folders(box)
  link_cmd = <<-SCRIPT
  function Link-Host {
    Param($Hostname)
    if (!(Test-Path -Path "$($Hostname)minicoin")) { return }
    New-Item -ItemType SymbolicLink -Path c:\\minicoin -Target "$($Hostname)minicoin" -Force
    New-Item -ItemType SymbolicLink -Path c:\\host -Target "$($Hostname)host" -Force
  }
  Link-Host -Hostname \\\\VBOXSVR\\
  Link-Host -Hostname "\\\\vmware-host\\Shared Folders\\-"
  cmd /c "rd c:\\Users\\host"
  New-Item -ItemType Junction -Path c:\\Users\\host -Target c:\\host -Force
  SCRIPT

  box.vm.provision "shell",
    inline: link_cmd
end

Vagrant.configure("2") do |config|
  machines = load_minicoin()
  machines.each do |machine|
    name = machine["name"]
    if name.nil?
      puts "==> Machine without name: #{machine}"
      next
    end
    machine_box = machine["box"]
    if machine_box.nil?
      puts "==> #{name}: Machine has no box set"
      next
    end
    machine_url = machine_box
    if machine_box.include?("$minicoin_key")
      minicoin_key = ENV['minicoin_key']
      if minicoin_key.nil?
        if ["validate"].include? ARGV[0]
          puts "==> #{name}: Box is private, but key is not set. Set 'minicoin_key' environment variable!"
        end
        next
      end
      machine_url = machine_url.gsub("$minicoin_key", minicoin_key)
      machine_box = machine_box.gsub("$minicoin_key/", "")
    end

    config.vm.define machine["name"], autostart: false do |box|
      if !machine["provider"].nil?
        box.vm.provider machine["provider"]
      end
  
      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      maker = machine_box.split(/\//).first
      sources = $urls[maker]
      unless sources.nil?
        box.vm.box_url = []
        if sources.is_a?(String)
          sources = [sources];
        end
        if File.file?("boxes/#{maker}/#{name}.json")
          box.vm.box_url = ["#{sources[0]}/#{machine_url}.json"]
        else
          sources.each do |source|
            box.vm.box_url += ["#{source}/#{machine_url}.box"]
          end
        end
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?
      if !is_windows
        box.vm.hostname = name
      end
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
      end

      ports = machine["ports"]
      if !ports.nil?
        struct_error = true
        if ports.is_a?(Array)
          ports.each do |port|
            if port.is_a?(Hash)
              struct_error = false
              port_guest = port["guest"]
              port_host = port["host"]
              port_id = port["id"]
              if !port_guest.nil? && !port_host.nil?
                if port_id == "rdp"
                  machine["rdp_port"] = port_host
                end
                box.vm.network "forwarded_port", id: port["id"],
                  guest: port_guest, guest_ip: port["guest_ip"],
                  host: port_host, host_ip: port["host_ip"],
                  protocol: port["protocol"],
                  auto_correct: port["auto_correct"]
              else
                puts "==> #{name}: port forwarding requires values for guest and host (#{port})"
              end
            end
          end
        else
        end
        if struct_error
          puts "==> #{name}: 'ports' needs to be a list of mappings"
        end
      end

      # Platform specific configurations
      guest_home = "/home/host"
      guest_filedir = ""

      if is_windows
        box.vm.guest = :windows
        guest_home = "/host"
        guest_filedir = "c:\\Users\\vagrant\\"

        # "Intel Pro/1000 MT Desktop" must be used on Windows
        machine["nictype1"] = "82540EM"

        # Test if winrm is available
        begin
          has_winrm = require 'winrm'
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        box.vm.guest = :darwin
        guest_home = "/Users/host"

        # "Intel Pro/1000 MT Server" must be used on Mac
        machine["nictype1"] = "82545EM"
      else
        # rely on defaults and vagrant autodetection for nix'es
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end

      virtualbox_setup(box, machine)
      vmware_setup(box, machine)

      if machine["shared_folders"] == "disabled"
        box.vm.synced_folder ".", "/minicoin", disabled: true
      elsif is_mac
        # folder sharing is not supported on BSD/Mac systems
        # instead, mount shared folders via sshfs
        box.vm.synced_folder ".", "/minicoin", disabled: true 

        # ensure users private key is on the guest for authenticating back to host
        key_file = "#{$PWD}/.vagrant/machines/#{name}/minicoin"
        authorized_keys = "#{$HOME}/.ssh/authorized_keys"

        # generate keys and authorize the guest to access the host
        box.trigger.before [:up] do |trigger|
          trigger.name = "Generating key pair and authorizing guest"
          trigger.ruby do |e,m|
            if !File.file?(key_file)
              `ssh-keygen -f #{key_file} -C minicoin@#{name} -q -N \"\"`
              public_key = File.read("#{key_file}.pub")
              open(authorized_keys, 'a') do |file|
                file.puts "#{public_key}"
              end
              File.chmod(0600, authorized_keys)
            end
          end
        end

        # delete the keys, and de-authorize the guest
        box.trigger.after [:destroy] do |trigger|
          trigger.name = "Removing key-pair and de-authorising guest"
          trigger.ruby do |e,m|
            File.open("#{authorized_keys}.new", 'w') do |out|
              out.chmod(File.stat(authorized_keys).mode)
              File.foreach(authorized_keys) do |line|
                out.puts line unless line =~ /minicoin@#{name}/
              end
            end
            File.rename("#{authorized_keys}.new", authorized_keys)
            File.delete(key_file) if File.exist?(key_file)
            File.delete("#{key_file}.pub") if File.exist?("#{key_file}.pub")
          end
        end

        # upload the private key to the guest
        if !["validate"].include? ARGV[0]
          box.vm.provision "file",
            source: key_file,
            destination: "#{guest_filedir}.ssh/#{$USER}"
          box.vm.provision "shell",
            inline: "chmod 0600 #{guest_filedir}.ssh/#{$USER}",
            upload_path: "/tmp/vagrant-shell/fix_permissions.sh"
        end

        host_home = $settings["home_share"]
        if host_home != "disabled"
          mac_share_folder(box, host_home, guest_home)
        end

        mac_share_folder(box, $PWD, "/minicoin")
      else
        host_home = $settings["home_share"]
        if host_home != "disabled"
          box.vm.synced_folder host_home, guest_home
        end
        box.vm.synced_folder ".", "/minicoin"
        if is_windows
          win_link_folders(box)
        end
      end

      # Copying files to guest
      if !is_windows || (box.vm.communicator == :winrm) # file provisioning via winssh is broken
	      if File.file?("#{$HOME}/.gitconfig")
          box.vm.provision "file", source: "#{$HOME}/.gitconfig", destination: "#{guest_filedir}.gitconfig"
        end
      end

      # Execution of provisioning script
      if ["up", "provision", "reload", "validate"].include? ARGV[0]
        roles = machine["roles"]
        unless roles.nil? or roles.empty?
          if roles.kind_of?(Array)
            roles.each do |role|
              add_role(box, role, name)
            end
          else
            add_role(box, roles, name)
          end
        end
      end
    end
  end
end
