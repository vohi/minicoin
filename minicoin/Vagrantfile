# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2.4"

# Import YAML
require 'yaml'
require 'net/http'
require 'zip'

$is_windows_host = !(ENV["windir"].nil?)
$HOME = ENV["HOME"]
$USER = ENV['USER']
if $is_windows_host
  $HOME = ENV["USERPROFILE"]
  $USER = ENV['USERNAME']
end

$PWD = File.dirname(__FILE__)
yaml = YAML.load_file(File.join($PWD, 'boxes.yml'))
$urls = yaml["urls"]
machines = yaml["machines"]

settings = yaml["settings"]
settings = [] if settings.nil?
settings["home_share"] = $HOME if settings["home_share"].nil?

user_machine_file = File.join($HOME, 'minicoin/boxes.yml');
if File.file?(user_machine_file)
  user_yaml = YAML.load_file(user_machine_file)
  user_machines = user_yaml["machines"]
  user_machines = [] if user_machines.nil?
  user_machines.each do |user_machine|
    idx = machines.find_index {|m| m["name"] == user_machine["name"] }
    if !idx.nil?
      machines[idx].each do |key, value|
        if !user_machine[key].nil?
          machines[idx][key] = user_machine[key]
        end
      end
    else
      machines << user_machine
    end
  end

  # a hash
  user_settings = user_yaml["settings"]
  if !user_settings.nil?
    user_settings.each do |key, value|
      settings[key] = value
    end
  end

  # a hash of arrays
  user_urls = user_yaml["urls"]
  if !user_urls.nil?
    user_urls.each do |key, array|
      array.each do |value|
        $urls[key] << value
      end
    end
  end
end

settings["home_share"] = settings["home_share"].gsub("$HOME", $HOME)
settings["home_share"] = settings["home_share"].gsub("~", $HOME)

def fetch_file(uri, local)
  begin
    downloader = Vagrant::Util::Downloader.new(uri, local)
    downloader.download!
  rescue => error
    puts "Error downloading #{uri}: #{error}"
    return false
  end
end

def insert_disk(box, disk_filename, role_params)
  disk_data = YAML.load_file(disk_filename)
  disk_file = disk_data["file"]
  disk_archive = disk_data["archive"]
  disk_urls = disk_data["urls"]
  if disk_urls.is_a?(String)
    disk_urls = [disk_urls]
  end
  disk_urls = [] if disk_urls.nil?
  disk_urls += $urls["disks"] unless $urls["disks"].nil?

  if disk_archive.nil?
    disk_archive = disk_file
  end

  disk_cache = "#{$PWD}/.diskcache"
  if ["up", "provision", "reload"].include? ARGV[0]
    Dir.mkdir(disk_cache) unless Dir.exist?(disk_cache)

    if !File.file?("#{disk_cache}/#{disk_file}")
      if !File.file?("#{disk_cache}/#{disk_archive}")
        disk_urls.each do |server|
          url = URI("#{server}/disks/#{disk_archive}")
          puts "Downloading '#{url}'..."
          if fetch_file(url, "#{disk_cache}/#{disk_archive}")
            break
          end
        end
      end
      if !File.file?("#{disk_cache}/#{disk_archive}")
        puts "Failed to download '#{disk_archive}' from any of #{disk_urls}"
      else
        puts "Extracting '#{disk_archive}'"
        Zip::File.open("#{disk_cache}/#{disk_archive}") do |zipfile|
          zipfile.extract("#{disk_file}", "#{disk_cache}/#{disk_file}")
        end
      end
    end
    if !File.file?("#{disk_cache}/#{disk_file}")
      puts "==> Disk file '#{disk_file}' not available"
      return false
    end

    box.vm.provider "virtualbox" do |vb|
      storage_params = [
        "storageattach", :id,
        "--medium", "#{disk_cache}/#{disk_file}",
      ]

      disk_settings = disk_data["settings"] unless disk_data.nil?
      if disk_settings.nil?
        disk_settings = {}
      end

      # default settings, disks can override
      disk_settings["storagectl"] = "SATA" unless !disk_settings["storagectl"].nil?

      if disk_file.end_with?(".iso")
        disk_settings["port"] = "1" unless !disk_settings["port"].nil?
        disk_settings["type"] = "dvddrive" unless !disk_settings["type"].nil?
      elsif disk_file.end_with?(".vdi")
        disk_settings["port"] = "2" unless !disk_settings["port"].nil?
        disk_settings["type"] = "hdd" unless !disk_settings["type"].nil?
        disk_settings["mtype"] = "multiattach" unless !disk_settings["mtype"]
      end

      # boxes can override disk settings
      if role_params.is_a?(Hash)
        role_params.each do |key, value|
          disk_settings[key] = value
        end
      end

      disk_settings.each do |key, value|
        storage_params += ["--#{key}", "#{value}"]
      end
      vb.customize storage_params
    end
  end
  return true
end

# expand environment variables in parameters
# and adjust any occurence of $HOME to the home on the guest
def expand_env(value, box)
  while (matches = value.match(/\$([A-Za-z0-9_]*)/))
    env_name = matches[1]
    if env_name == ""
      break
    end
    env_val = ENV[env_name]
    if env_val.nil?
      return nil
    else
      host_home = settings["home_share"]
      if env_val.start_with?(host_home)
        if box.vm.guest == :windows
          env_val = env_val.sub(host_home, "C:\\\\Users\\\\host")
        else
          env_val = env_val.sub(host_home, "/home/host")
        end
      end
      value = value.sub("$#{env_name}", env_val)
      if box.vm.guest == :windows
        value = value.gsub("/", "\\\\")
      end
    end
  end
  return value
end

def add_role(box, role, name)
  role_params = role
  if role.is_a?(Hash) # parameterized role
    if !role["docker"].nil?
      role_params["name"] = role["docker"]
      role = "docker"
    else
      role = role["role"]
      role_params.delete("role")
    end
    role_params.each do |key, value|
      if value.nil?
        next
      end
      if value.is_a?(String)
        new_value = expand_env(value, box)
        if new_value.nil?
          puts "==> #{name}: Unexpanded environment variable in '#{value}' - skipping role '#{role}'"
          return
        end
        role_params[key] = new_value
      elsif value.is_a?(Array)
        array = []
        value.each do |entry|
          new_entry = expand_env(entry, box)
          if new_entry.nil?
            puts "==> #{name}: Unexpanded environment variable in '#{entry}' - skipping role '#{role}'"
            return
          end
          array << new_entry
        end
        role_params[key] = array
      end
    end
  end

  # user can add or override roles
  role_path = File.join($HOME, "minicoin/roles/#{role}")
  if !File.exist?(role_path)
    role_path = "#{$PWD}/roles/#{role}"
  end
  activity = false
  if File.file?("#{role_path}/playbook.yml")
    box.vm.provision "ansible" do |ansible|
      ansible.playbook = "#{role_path}/playbook.yml"
      ansible.become = true unless box.vm.guest == :windows
    end
    activity = true
  elsif File.file?("#{role_path}/disk.yml")
    activity = true
    if !insert_disk(box, "#{role_path}/disk.yml", role_params)
      puts "==> #{name}: Attaching disk failed for role '#{role}'"
    end
  elsif File.file?("#{role_path}/Dockerfile")
    docker_args = "--rm"
    role_params.each do |param, value|
      if value.nil?
        docker_args += " --#{param}"
      elsif value.is_a?(Array)
        value.each do |entry|
          docker_args += " --#{param} \"#{entry}\""
        end
      else
        docker_args += " --#{param} \"#{value}\""
      end
    end
    box.vm.provision "file",
      source: "#{role_path}/Dockerfile",
      destination: "#{role}/Dockerfile"
    box.vm.provision "docker" do |docker|
      docker.build_image "#{role}", args: docker_args
    end
    activity = true
  elsif role == "docker"
    detach = true
    restart = "always"

    name = role_params["docker"]
    image = role_params["image"]
    cmd = role_params["cmd"]
    args = role_params["args"]
    detach = (role_params["detach"] == true) unless role_params["detach"].nil?
    restart = role_params["restart"] unless role_params["restart"].nil?
    box.vm.provision "docker" do |docker|
      docker.run name,
      image: image,
      cmd: cmd,
      auto_assign_name: false,
      args: args,
      daemonize: detach,
      restart: restart
    end
    activity = true
  end

  # always check for a provisioning script
  script_ext = ".sh"
  upload_path = "/tmp/vagrant-shell/"
  if box.vm.guest == :windows
    script_ext = ".cmd"
    if File.file?("#{role_path}/provision.ps1")
      script_ext = ".ps1"
    end
    upload_path = "c:\\Windows\\temp\\"
  end
  upload_path += "provision_#{role}#{script_ext}"
  provisioning_file = "#{role_path}/provision#{script_ext}"
  if File.file?(provisioning_file)
    activity = true
    script_args = [role, name, $USER]
    if role_params.is_a?(Hash)
      role_params.each do |key, value|
        script_args += ["--#{key}"]
        script_args += ["#{value}"] unless value.nil?
      end
    end
    box.vm.provision "shell", name: "#{role}", path: "#{provisioning_file}",
      args: script_args,
      upload_path: upload_path,
      privileged: true
  end

  if ! activity
    puts "==> #{role}: Provisioning script at '#{provisioning_file}' not found!"
  else
    # check for pre-/post-provisioning script to run locally
    if File.file?("#{role_path}/pre-provision.sh")
      box.trigger.before [:up, :provision] do |trigger|
        trigger.name = "before #{role}"
        trigger.run = {
          path: "#{role_path}/pre-provision.sh",
          args: name
        }
      end
    end

    if File.file?("#{role_path}/post-provision.sh")
      box.trigger.after [:up, :provision] do |trigger|
        trigger.name = "after #{role}"
        trigger.run = {
          path: "#{role_path}/post-provision.sh",
          args: name
        }
      end
    end
  end
end

def mac_share_folder(box, host_path, guest_path)
  guest_base = guest_path.split('/').last

  if $is_windows_host
    host_path = "/#{host_path}".gsub("\\", "/")
  end

  sshfs_options = \
    "reconnect,allow_other,defer_permissions,cache=no," \
    "IdentityFile=~/.ssh/#{$USER},StrictHostKeyChecking=no," \
    "volname=#{guest_base}"
  ssh_cmd = \
    "HOST_IP=$(echo $SSH_CONNECTION | cut -f 1 -d ' ') && " \
    "sshfs -o #{sshfs_options} #{$USER}@$HOST_IP"

  mount_point = "/tmp/vagrant-#{guest_base}"
  upload_path = "/tmp/vagrant-shell/#{guest_base}_mount"
  mount_command = {
    privileged: false,
    upload_path: "#{upload_path}.sh",
    inline: \
    "if [[ ! -d #{mount_point} ]]; then " \
    "  mkdir #{mount_point}; " \
    "fi && "\
    "if ! (mount | grep #{mount_point} > /dev/null); then " \
    "  #{ssh_cmd}:#{host_path} #{mount_point}; " \
    "fi && " \
    "if [[ ! -d #{guest_path} ]]; then " \
    "  sudo ln -fs #{mount_point} #{guest_path}; " \
    "fi || true"
  }
  box.vm.provision "shell", mount_command
  box.trigger.after [:up, :reload] do |trigger|
    trigger.name = "Mounting shared folder #{host_path}"
    trigger.run_remote = mount_command
  end
end

Vagrant.configure("2") do |config|
  machines.each do |machine|
    name = machine["name"]
    machine_box = machine["box"]
    if machine_box.nil?
      puts "==> #{name}: Machine has no box set"
      exit
    end
    machine_url = machine_box
    if machine_box.include?("$private")
      minicoin_key = ENV['minicoin_key']
      if minicoin_key.nil?
        puts "==> #{name}: Box is private, but key is not set. Set 'minicoin_key' environment variable!"
        next
      end
      machine_url = machine_url.gsub("$private", minicoin_key)
      machine_box = machine_box.gsub("$private/", "")
    end

    config.vm.define machine["name"], autostart: false do |box|
      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      maker = machine_box.split(/\//).first
      sources = $urls[maker]
      unless sources.nil?
        box.vm.box_url = []
        if sources.is_a?(String)
          sources = [sources];
        end
        sources.each do |source|
          box.vm.box_url += ["#{source}/#{machine_url}.box"]
        end
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?
      if !is_windows
        box.vm.hostname = name
      end
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
      end

      # VirtualBox specific settings
      box.vm.provider "virtualbox" do |vb|
        vb.memory = machine["memory"] unless machine["memory"].nil?
        vb.cpus = machine["cpus"] unless machine["cpus"].nil?
        vb.gui = machine["gui"] unless machine["gui"].nil?
        vb.customize ["modifyvm", :id, "--vram", machine["vram"]] unless machine["vram"].nil?
        vb.name = name
        if is_windows # "Intel Pro/1000 MT Desktop" must be used on Windows
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82540EM"
          ]
        elsif is_mac # "Intel Pro/1000 MT Server" must be used on Mac
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82545EM"
          ]
        end

        vb.customize [
          "modifyvm", :id,
          "--clipboard", "bidirectional"
        ]
      end

      # Platform specific configurations
      guest_home = "/home/host"
      guest_filedir = ""

      if is_windows
        box.vm.guest = :windows
        guest_home = "/host"
        guest_filedir = "c:\\Users\\vagrant\\"

        # Test if winrm is available
        begin
          has_winrm = require 'winrm'
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        guest_home = "/Users/host"
      else
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end

      if machine["shared_folders"] == "disabled"
        box.vm.synced_folder ".", "/minicoin", disabled: true
      elsif is_mac
        # folder sharing is not supported on BSD/Mac systems
        # instead, mount shared folders via sshfs
        box.vm.synced_folder ".", "/minicoin", disabled: true 

        # ensure users private key is on the guest for authenticating back to host
        key_file = "#{$PWD}/.vagrant/machines/#{name}/minicoin"
        authorized_keys = "#{$HOME}/.ssh/authorized_keys"

        # generate keys and authorize the guest to access the host
        box.trigger.before [:up] do |trigger|
          trigger.name = "Generating key pair and authorizing guest"
          trigger.ruby do |e,m|
            if !File.file?(key_file)
              `ssh-keygen -f #{key_file} -C minicoin@#{name} -q -N \"\"`
              public_key = File.read("#{key_file}.pub")
              open(authorized_keys, 'a') do |file|
                file.puts "#{public_key}"
              end
              File.chmod(0600, authorized_keys)
            end
          end
        end

        # delete the keys, and de-authorize the guest
        box.trigger.after [:destroy] do |trigger|
          trigger.name = "Removing key-pair and de-authorising guest"
          trigger.ruby do |e,m|
            File.open("#{authorized_keys}.new", 'w') do |out|
              out.chmod(File.stat(authorized_keys).mode)
              File.foreach(authorized_keys) do |line|
                out.puts line unless line =~ /minicoin@#{name}/
              end
            end
            File.rename("#{authorized_keys}.new", authorized_keys)
            File.delete(key_file) if File.exist?(key_file)
            File.delete("#{key_file}.pub") if File.exist?("#{key_file}.pub")
          end
        end

        # upload the private key to the guest
        if !["validate"].include? ARGV[0]
          box.vm.provision "file",
            source: key_file,
            destination: "#{guest_filedir}.ssh/#{$USER}"
          box.vm.provision "shell",
            inline: "chmod 0600 #{guest_filedir}.ssh/#{$USER}",
            upload_path: "/tmp/vagrant-shell/fix_permissions.sh"
        end

        host_home = settings["home_share"]
        if host_home != "disabled"
          mac_share_folder(box, host_home, guest_home)
        end

        mac_share_folder(box, $PWD, "/minicoin")
      else
        host_home = settings["home_share"]
        if host_home != "disabled"
          box.vm.synced_folder host_home, guest_home
        end
        box.vm.synced_folder ".", "/minicoin"
        if is_windows
          box.vm.provision "shell", inline: \
            'cmd /c "rd c:\\minicoin & rd c:\\host & rd c:\\Users\\host & ' \
            'mklink /D C:\\minicoin \\\\VBOXSRV\\minicoin & ' \
            'mklink /D C:\\host \\\\VBOXSRV\\host & ' \
            'mklink /J C:\\Users\\host C:\\host"'
        end
      end

      # Copying files to guest
      if !is_windows || (box.vm.communicator == :winrm) # file provisioning via winssh is broken
	      if File.file?("#{$HOME}/.gitconfig")
          box.vm.provision "file", source: "#{$HOME}/.gitconfig", destination: "#{guest_filedir}.gitconfig"
        end
      end

      # Execution of provisioning script
      if ["up", "provision", "reload", "validate"].include? ARGV[0]
        roles = machine["roles"]
        unless roles.nil? or roles.empty?
          if roles.kind_of?(Array)
            roles.each do |role|
              add_role(box, role, name)
            end
          else
            add_role(box, roles, name)
          end
        end
      end
    end
  end
end
