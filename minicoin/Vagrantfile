# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2.4"

require 'yaml'
require 'json'
require 'net/http'

require_relative "lib/local_command.rb"
require_relative "lib/expand_env.rb"
require_relative "lib/loader.rb"
require_relative "lib/roles.rb"
require_relative "lib/sharing.rb"
require_relative "lib/virtualbox.rb"
require_relative "lib/vmware_desktop.rb"
require_relative "lib/azure.rb"

$is_windows_host = !(ENV["windir"].nil?)
$has_winrm = false
$HOME = ENV["HOME"]
$USER = ENV['USER']
if $is_windows_host
  $HOME = ENV["USERPROFILE"]
  $USER = ENV['USERNAME']
end

$PWD = File.dirname(__FILE__)

Vagrant.configure("2") do |config|
  machines = load_minicoin()
  machines.each do |machine|
    name = machine["name"]    
    if name.nil?
      puts "==> Machine without name: #{machine}"
      next
    end
    machine_box = machine["box"]
    machine_url = machine_box
    if !machine_box.nil?
      if machine_box.include?("$minicoin_key")
        minicoin_key = ENV['minicoin_key']
        if minicoin_key.nil?
          if ["validate"].include? ARGV[0]
            puts "==> #{name}: Box is private, but key is not set. Set 'minicoin_key' environment variable!"
          end
          next
        end
        machine_url = machine_url.gsub("$minicoin_key", minicoin_key)
        machine_box = machine_box.gsub("$minicoin_key/", "")
      end
      machine_box = expand_env(machine_box, nil)
    end
    if machine_box.nil?
      puts "==> #{name}: Machine has no box set"
      next
    end

    config.vm.define machine["name"], autostart: false do |box|
      if !machine["provider"].nil?
        box.vm.provider machine["provider"]
      end
  
      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      sources = $urls[machine_box.split(/\//).first]
      unless sources.nil?
        box.vm.box_url = []
        if sources.is_a?(String)
          sources = [sources];
        end
        if File.file?("boxes/#{machine_box}.json")
          box.vm.box_url = ["#{sources[0]}/#{machine_url}.json"]
        else
          sources.each do |source|
            box.vm.box_url += ["#{source}/#{machine_url}.box"]
          end
        end
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?

      ports = machine["ports"]
      if !ports.nil?
        struct_error = true
        if ports.is_a?(Array)
          ports.each do |port|
            if port.is_a?(Hash)
              struct_error = false
              port_guest = port["guest"]
              port_host = port["host"]
              port_id = port["id"]
              if !port_guest.nil? && !port_host.nil?
                if port_id == "rdp"
                  machine["rdp_port"] = port_host
                end
                box.vm.network "forwarded_port", id: port["id"],
                  guest: port_guest, guest_ip: port["guest_ip"],
                  host: port_host, host_ip: port["host_ip"],
                  protocol: port["protocol"],
                  auto_correct: port["auto_correct"]
              else
                puts "==> #{name}: port forwarding requires values for guest and host (#{port})"
              end
            end
          end
        else
        end
        if struct_error
          puts "==> #{name}: 'ports' needs to be a list of mappings"
        end
      end

      # Platform specific configurations
      if is_windows
        box.vm.guest = :windows
        ENV["GUEST_HOMES"] = "Users"

        # "Intel Pro/1000 MT Desktop" must be used on Windows
        machine["nictype1"] = "82540EM"

        # Test if winrm is available
        begin
          $has_winrm = require 'winrm' unless $has_winrm
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if $has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        box.vm.guest = :darwin
        ENV["GUEST_HOMES"] = "Users"

        # "Intel Pro/1000 MT Server" must be used on Mac
        machine["nictype1"] = "82545EM"
      else
        box.vm.guest = machine["guest"] unless machine["guest"].nil?
        ENV["GUEST_HOMES"] = "home"
        # rely on defaults and vagrant autodetection for nix'es
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end
      if machine["basebox"] == true
        box.ssh.insert_key = false
      end
      config.ssh.shell = machine["shell"] unless machine["shell"].nil?

      # private network setup
      box.vm.hostname = name
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
        machine["nictype2"] = machine["nictype1"] if machine["nictype2"].nil?
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
        machine["nictype2"] = machine["nictype1"] if machine["nictype2"].nil?
      end

      # map virtual machine configurations to provider specific settings
      virtualbox_setup(box, machine)
      vmware_setup(box, machine)
      azure_setup(box, machine)

      # folder sharing, taking guest OS and provider specific quirks into account
      default_shares = $settings["defaults"]["shared_folders"]
      default_shares = [default_shares] unless default_shares.kind_of?(Array)
      machine_shares = machine["shared_folders"]
      machine_shares = [machine_shares]  unless machine_shares.kind_of?(Array)
      shares = default_shares + machine_shares

      if shares.include?("disabled")
        box.vm.synced_folder ".", "/minicoin", disabled: true
      else
        share_folders(box, machine, shares)
      end

      # Definition of provisioning steps
      default_roles = $settings["defaults"]["roles"]
      default_roles = [default_roles] unless default_roles.kind_of?(Array)

      machine_roles = machine["roles"]
      machine_roles = [machine_roles] unless machine_roles.kind_of?(Array)

      # add_role modifies, so make a deep copy of default_roles
      roles = Marshal.load(Marshal.dump(default_roles))
      roles.concat(machine_roles)
      roles.each do |role|
        add_role(box, role, name) unless role.nil?
      end
    end
  end
end
