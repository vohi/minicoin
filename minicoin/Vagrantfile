# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2"

# Import YAML
require 'yaml'
require 'net/http'

yaml = YAML.load_file(File.join(File.dirname(__FILE__), 'boxes.yml'))
$urls = yaml["urls"]
machines = yaml["machines"]

def fetch_file(uri, local)
  begin
    Net::HTTP.start(uri.host) do |http|
      req = Net::HTTP::Get.new(uri)
      http.request(req) do |response|
        case response
        when Net::HTTPSuccess then
          open("#{local}", "wb") do |file|
            response.read_body do |chunk|
              file.write(chunk)
            end
          end
        else
          puts "Error downloading: #{response.value}"
        end
      end
    end
  rescue
      puts "Error downloading #{uri}"
  end
end

def add_role(box, role)
  role_path = "#{__dir__}#{role_path}/roles/#{role}"
  activity = false
  if File.file?("#{role_path}/playbook.yml")
    box.vm.provision "ansible" do |ansible|
      ansible.playbook = "#{role_path}/playbook.yml"
      ansible.become = true unless box.vm.guest == :windows
    end
    activity = true
  elsif File.file?("#{role_path}/disk")
    activity = true
    disk_file = File.read("#{role_path}/disk").strip
    iso_path = "#{__dir__}/.isocache"
    if ["up", "provision", "reload"].include? ARGV[0]
      Dir.mkdir(iso_path) unless Dir.exist?(iso_path)

      if !File.file?("#{iso_path}/#{disk_file}")
        puts "Downloading '#{disk_file}'..."
        $urls.each do |url|
          url.each do |key, value|
            uri = URI("#{value}/#{key}/#{disk_file}")
            puts "Trying to download '#{uri}'..."
            fetch_file(uri, "#{iso_path}/#{disk_file}")
          end
        end
      end
      if !File.file?("#{iso_path}/#{disk_file}")
        puts "==> #{role}: ISO file '#{disk_file}' not available"
      else
        box.vm.provider "virtualbox" do |vb|
            vb.customize [
            "storageattach", :id,
            "--storagectl", "SATA",
            "--port", "1",
            "--type", "dvddrive",
            "--medium", "#{iso_path}/#{disk_file}"
          ]
        end
      end
    end
  end

  # always check for a provisioning script
  script_ext = ".sh"
  upload_path = "/tmp/vagrant-shell"
  if box.vm.guest == :windows
    script_ext = ".cmd"
    if File.file?("#{role_path}/provision.ps1")
      script_ext = ".ps1"
    end
    upload_path = "c:\\Windows\\temp\\"
  end
  provisioning_file = "#{role_path}/provision#{script_ext}"
  if File.file?(provisioning_file)
    activity = true
    user = ENV['USER']
    box.vm.provision "shell", name: "#{role}", path: "#{provisioning_file}",
      args: ["#{role}", "#{user}"],
      upload_path: upload_path,
      privileged: true
  end

  if ! activity
    puts "==> #{role}: Provisioning script at '#{provisioning_file}' not found!"
  end
end

Vagrant.configure("2") do |config|
  if ARGV[0] == "up" and ARGV.length == 1
    puts "This is a multi-machine environment. The following machines are available:"
    puts
    machines.each do |machine|
      puts "- #{machine['name']}"
    end
    puts
    puts "Please, specify which machine(s) you want to bring up."
    exit
  end

  machines.each do |machine|
    config.vm.define machine["name"] do |box|
      name = machine["name"]
      machine_box = machine["box"]

      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      $urls.each do |url|
        maker = machine_box.split(/\//).first
        source = url[maker]
        unless source.nil?
          box.vm.box_url = [
            "#{source}/#{machine_box}.box",
            "#{source}/#{machine_box}-base.box"
          ]
        end
      end
      box.vm.box = machine_box
      if !is_windows
        box.vm.hostname = name
      end
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
      end

      # VirtualBox specific settings
      box.vm.provider "virtualbox" do |vb|
        vb.memory = machine["memory"] unless machine["memory"].nil?
        vb.cpus = machine["cpus"] unless machine["cpus"].nil?
        vb.gui = machine["gui"] unless machine["gui"].nil?
        vb.customize ["modifyvm", :id, "--vram", machine["vram"]] unless machine["vram"].nil?
        vb.name = name
        if is_windows || is_mac # "Intel Pro/1000 MT Desktop" must be used on Windows and Mac
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82540EM"
          ]
        end

        vb.customize [
          "modifyvm", :id,
          "--clipboard", "bidirectional"
        ]
      end

      # Platform specific configurations
      guest_home = "/home/host"
      guest_filedir = ""

      if is_windows
        box.vm.guest = :windows
        guest_home = "/host"
        guest_filedir = "c:\\Users\\vagrant\\"

        # Test if winrm is available
        begin
          has_winrm = require 'winrm'
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        guest_home = "/Users/host"
      else
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end

      if machine["shared_folders"] == "disabled"
        box.vm.synced_folder ".", "/vagrant", disabled: true
      elsif is_mac
        box.vm.synced_folder ".", "/vagrant", type: "rsync", rsync__chown: false
      else
        box.vm.synced_folder "~", "#{guest_home}"
        box.vm.synced_folder ".", "/vagrant"
        if is_windows
          box.vm.provision "shell", inline: "cmd /c mklink /D C:\\vagrant \\\\VBOXSRV\\vagrant"
          box.vm.provision "shell", inline: "cmd /c mklink /D C:\\Users\\host \\\\VBOXSRV\\host"
        end
      end

      # Copying files to guest
      if !is_windows || box.vm.communicator == :winrm # file provisioning via winssh is broken
        box.vm.provision "file", source: "~/.gitconfig", destination: "#{guest_filedir}.gitconfig"
      end

      # Execution of provisioning script
      if ["up", "provision", "reload", "validate"].include? ARGV[0]
        coin_root = ENV['COIN_ROOT']
        if coin_root.nil? || !File.exists?(coin_root)
          puts "==> #{name}: COIN_ROOT '#{coin_root}' empty or does not exist" unless ARGV[0] == "validate"
        else
          if !is_windows || box.vm.communicator == :winrm
            box.vm.provision "file", source: "#{coin_root}/", destination: "#{guest_filedir}coin"
          end
        end

        roles = machine["roles"]
        unless roles.nil? or roles.empty?
          if roles.kind_of?(Array)
            roles.each do |role|
              add_role(box, role)
            end
          else
            add_role(box, roles)
          end
        end
      end
    end
  end
end
