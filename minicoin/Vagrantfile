# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2.4"

# Import YAML
require 'yaml'
require 'net/http'
require 'zip'

$is_windows_host = !(ENV["windir"].nil?)
$HOME = ENV["HOME"]
if $is_windows_host
  $HOME = ENV["USERPROFILE"]
end

yaml = YAML.load_file(File.join(File.dirname(__FILE__), 'boxes.yml'))
$urls = yaml["urls"]
machines = yaml["machines"]

settings = yaml["settings"]
settings = [] if settings.nil?
settings["home_share"] = $HOME if settings["home_share"].nil?

user_machine_file = File.join(ENV['HOME'], 'minicoin/boxes.yml');
if File.file?(user_machine_file)
  user_yaml = YAML.load_file(user_machine_file)
  user_machines = user_yaml["machines"]
  user_machines.each do |user_machine|
    idx = machines.find_index {|m| m["name"] == user_machine["name"] }
    if !idx.nil?
      machines[idx].each do |key, value|
        if !user_machine[key].nil?
          machines[idx][key] = user_machine[key]
        end
      end
    else
      machines << user_machine
    end
  end

  user_settings = user_yaml["settings"]
  if !user_settings.nil?
    user_settings.each do |key, value|
      settings[key] = value
    end
  end
end

def fetch_file(uri, local)
  begin
    downloader = Vagrant::Util::Downloader.new(uri, local)
    downloader.download!
  rescue => error
    puts "Error downloading #{uri}: #{error}"
    return false
  end
end

def insert_disk(box, disk_filename, role_params)
  disk_data = YAML.load_file(disk_filename)
  disk_file = disk_data["file"]
  disk_archive = disk_data["archive"]
  disk_urls = disk_data["urls"]
  if disk_urls.is_a?(String)
    disk_urls = [disk_urls]
  end
  disk_urls = [] if disk_urls.nil?
  disk_urls += $urls["disks"] unless $urls["disks"].nil?

  if disk_archive.nil?
    disk_archive = disk_file
  end

  disk_cache = "#{__dir__}/.diskcache"
  if ["up", "provision", "reload"].include? ARGV[0]
    Dir.mkdir(disk_cache) unless Dir.exist?(disk_cache)

    if !File.file?("#{disk_cache}/#{disk_file}")
      if !File.file?("#{disk_cache}/#{disk_archive}")
        disk_urls.each do |server|
          url = URI("#{server}/disks/#{disk_archive}")
          puts "Downloading '#{url}'..."
          if fetch_file(url, "#{disk_cache}/#{disk_archive}")
            break
          end
        end
      end
      if !File.file?("#{disk_cache}/#{disk_archive}")
        puts "Failed to download '#{disk_archive}' from any of #{disk_urls}"
      else
        puts "Extracting '#{disk_archive}'"
        Zip::File.open("#{disk_cache}/#{disk_archive}") do |zipfile|
          zipfile.extract("#{disk_file}", "#{disk_cache}/#{disk_file}")
        end
      end
    end
    if !File.file?("#{disk_cache}/#{disk_file}")
      puts "==> Disk file '#{disk_file}' not available"
      return false
    end

    box.vm.provider "virtualbox" do |vb|
      storage_params = [
        "storageattach", :id,
        "--medium", "#{disk_cache}/#{disk_file}",
      ]

      disk_settings = disk_data["settings"] unless disk_data.nil?
      if disk_settings.nil?
        disk_settings = {}
      end

      # default settings, disks can override
      disk_settings["storagectl"] = "SATA" unless !disk_settings["storagectl"].nil?

      if disk_file.end_with?(".iso")
        disk_settings["port"] = "1" unless !disk_settings["port"].nil?
        disk_settings["type"] = "dvddrive" unless !disk_settings["type"].nil?
      elsif disk_file.end_with?(".vdi")
        disk_settings["port"] = "2" unless !disk_settings["port"].nil?
        disk_settings["type"] = "hdd" unless !disk_settings["type"].nil?
        disk_settings["mtype"] = "multiattach" unless !disk_settings["mtype"]
      end

      # boxes can override disk settings
      if role_params.is_a?(Hash)
        role_params.each do |key, value|
          disk_settings[key] = value
        end
      end

      disk_settings.each do |key, value|
        storage_params += ["--#{key}", "#{value}"]
      end
      vb.customize storage_params
    end
  end
  return true
end

def add_role(box, role, name)
  role_params = role
  if role.is_a?(Hash)
    role = role["role"]
    role_params.delete("role")
    role_params.each do |key, value|
      if value.nil?
        continue
      end
      if value.is_a?(String) and matches = value.match(/\$([A-Z_]*)/)
        env_val = ENV[matches[1]]
        host_home = $HOME
        if env_val.nil?
          puts "==> #{name}: Environment variable '$#{matches[1]}' not set - skipping role '#{role}'"
          return
        elsif env_val.start_with?(host_home)
          if box.vm.guest == :windows
            env_val = env_val.sub(host_home, "C:\\\\Users\\\\host")
            env_val = env_val.gsub("/", "\\\\")
          else
            env_val = env_val.sub(host_home, "/home/host")
          end
        end
        role_params[key] = env_val
      end
    end
  end

  role_path = "#{__dir__}#{role_path}/roles/#{role}"
  activity = false
  if File.file?("#{role_path}/playbook.yml")
    box.vm.provision "ansible" do |ansible|
      ansible.playbook = "#{role_path}/playbook.yml"
      ansible.become = true unless box.vm.guest == :windows
    end
    activity = true
  elsif File.file?("#{role_path}/disk.yml")
    activity = true
    if !insert_disk(box, "#{role_path}/disk.yml", role_params)
      puts "==> #{name}: Attaching disk failed for role '#{role}'"
    end
  end

  # always check for a provisioning script
  script_ext = ".sh"
  upload_path = "/tmp/vagrant-shell/"
  if box.vm.guest == :windows
    script_ext = ".cmd"
    if File.file?("#{role_path}/provision.ps1")
      script_ext = ".ps1"
    end
    upload_path = "c:\\Windows\\temp\\"
  end
  upload_path += "provision_#{role}#{script_ext}"
  provisioning_file = "#{role_path}/provision#{script_ext}"
  if File.file?(provisioning_file)
    activity = true
    script_args = [role, name, ENV['USER']]
    if role_params.is_a?(Hash)
      role_params.each do |key, value|
        script_args += ["--#{key}"]
        script_args += ["#{value}"] unless value.nil?
      end
    end
    box.vm.provision "shell", name: "#{role}", path: "#{provisioning_file}",
      args: script_args,
      upload_path: upload_path,
      privileged: true
  end

  if ! activity
    puts "==> #{role}: Provisioning script at '#{provisioning_file}' not found!"
  else
    # check for pre-/post-provisioning script to run locally
    if File.file?("#{role_path}/pre-provision.sh")
      box.trigger.before [:up, :provision] do |trigger|
        trigger.name = "before #{role}"
        trigger.run = {
          path: "#{role_path}/pre-provision.sh",
          args: name
        }
      end
    end

    if File.file?("#{role_path}/post-provision.sh")
      box.trigger.after [:up, :provision] do |trigger|
        trigger.name = "after #{role}"
        trigger.run = {
          path: "#{role_path}/post-provision.sh",
          args: name
        }
      end
    end
  end
end

Vagrant.configure("2") do |config|
  if ARGV[0] == "up" and ARGV.length == 1
    puts "This is a multi-machine environment. The following machines are available:"
    puts
    machines.each do |machine|
      puts "- #{machine['name']}"
    end
    puts
    puts "Please, specify which machine(s) you want to bring up."
    exit
  end

  machines.each do |machine|
    config.vm.define machine["name"] do |box|
      name = machine["name"]
      machine_box = machine["box"]

      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      maker = machine_box.split(/\//).first
      sources = $urls[maker]
      unless sources.nil?
        box.vm.box_url = []
        if sources.is_a?(String)
          sources = [sources];
        end
        sources.each do |source|
          box.vm.box_url += ["#{source}/#{machine_box}.box"]
        end
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?
      if !is_windows
        box.vm.hostname = name
      end
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
      end

      # VirtualBox specific settings
      box.vm.provider "virtualbox" do |vb|
        vb.memory = machine["memory"] unless machine["memory"].nil?
        vb.cpus = machine["cpus"] unless machine["cpus"].nil?
        vb.gui = machine["gui"] unless machine["gui"].nil?
        vb.customize ["modifyvm", :id, "--vram", machine["vram"]] unless machine["vram"].nil?
        vb.name = name
        if is_windows # "Intel Pro/1000 MT Desktop" must be used on Windows
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82540EM"
          ]
        elsif is_mac # "Intel Pro/1000 MT Server" must be used on Mac
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82545EM"
          ]
        end

        vb.customize [
          "modifyvm", :id,
          "--clipboard", "bidirectional"
        ]
      end

      # Platform specific configurations
      guest_home = "/home/host"
      guest_filedir = ""

      if is_windows
        box.vm.guest = :windows
        guest_home = "/host"
        guest_filedir = "c:\\Users\\vagrant\\"

        # Test if winrm is available
        begin
          has_winrm = require 'winrm'
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        guest_home = "/Users/host"
      else
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end

      if machine["shared_folders"] == "disabled"
        box.vm.synced_folder ".", "/minicoin", disabled: true
      elsif is_mac
        box.vm.synced_folder ".", "/minicoin", disabled: true # not supported on BSD systems
        # box.vm.synced_folder ".", "/minicoin", type: "smb" # requires sharing, and buggy
        # box.vm.synced_folder ".", "/minicoin", type: "nfs" # buggy
        # box.vm.synced_folder ".", "/minicoin", type: "rsync", rsync__chown: false # slow
        # mount shared folders via sshfs, both when privisioning, and after booting
        host_home = settings["home_share"]
        host_user = ENV['USER']
        if $is_windows_host && host_user.nil?
          host_user = ENV['USERNAME']
        end
        host_pwd = File.dirname(__FILE__)
        if $is_windows_host
          host_pwd = "/#{host_pwd}"
          host_pwd = host_pwd.gsub("\\", "/")
        end
        sshfs_options = \
          "reconnect,allow_other,defer_permissions,auto_cache," \
          "IdentityFile=~/.ssh/#{host_user},StrictHostKeyChecking=no"
        # ensure users private key is on the guest for authenticating back to host
        if !File.file?("#{$HOME}/.ssh/id_rsa")
          if ["up", "provision", "reload", "validate"].include? ARGV[0]
            puts "==> #{name}: Private SSH key not found in #{$HOME}/.ssh/id_rsa, can't share folders with Mac guest"
          end
        else
          box.vm.provision "file",
            source: "#{$HOME}/.ssh/id_rsa",
            destination: "#{guest_filedir}.ssh/#{host_user}"
          box.vm.provision "shell",
            inline: "chmod 0600 #{guest_filedir}.ssh/#{host_user}",
            upload_path: "/tmp/vagrant-shell/fix_permissions.sh"

          ssh_cmd = \
            "HOST_IP=$(echo $SSH_CONNECTION | cut -f 1 -d ' ') && " \
            "sshfs -o #{sshfs_options} #{host_user}@$HOST_IP"
          if host_home != "disabled"
            if $is_windows_host
              host_home = "/#{host_home}"
              host_home = host_home.gsub("\\", "/")
            end
            home_mount_command = {
              privileged: false,
              upload_path: "/tmp/vagrant-shell/home_mount.sh",
              inline: \
              "mkdir /tmp/vagrant-host && #{ssh_cmd}:#{host_home} /tmp/vagrant-host && " \
              "sudo ln -s /tmp/vagrant-host #{guest_home} || true"
            }
            box.vm.provision "shell", home_mount_command
            box.trigger.after [:up, :reload] do |trigger|
              trigger.name = "Mounting shared home folder #{host_home}"
              trigger.run_remote = home_mount_command
            end
          end
          pwd_mount_command = {
            privileged: false,
            upload_path: "/tmp/vagrant-shell/minicoin_mount.sh",
            inline: \
            "mkdir /tmp/vagrant-minicoin && #{ssh_cmd}:#{host_pwd} /tmp/vagrant-minicoin && " \
            "sudo ln -s /tmp/vagrant-minicoin /minicoin || true"
          }

          box.vm.provision "shell", pwd_mount_command
          box.trigger.after [:up, :reload] do |trigger|
            trigger.name = "Mounting vagrant folder #{host_pwd}"
            trigger.run_remote = pwd_mount_command
          end
        end
      else
        host_home = settings["home_share"]
        if host_home != "disabled"
          box.vm.synced_folder host_home, guest_home
        end
        box.vm.synced_folder ".", "/minicoin"
        if is_windows
          box.vm.provision "shell", inline: \
            'cmd /c "rd c:\\minicoin & rd c:\\host & rd c:\\Users\\host & ' \
            'mklink /D C:\\minicoin \\\\VBOXSRV\\minicoin & ' \
            'mklink /D C:\\host \\\\VBOXSRV\\host & ' \
            'mklink /J C:\\Users\\host C:\\host"'
        end
      end

      # Copying files to guest
      if !is_windows || box.vm.communicator == :winrm # file provisioning via winssh is broken
	      if File.file?("#{$HOME}/.gitconfig")
          box.vm.provision "file", source: "#{$HOME}/.gitconfig", destination: "#{guest_filedir}.gitconfig"
        end
      end

      # Execution of provisioning script
      if ["up", "provision", "reload", "validate"].include? ARGV[0]
        roles = machine["roles"]
        unless roles.nil? or roles.empty?
          if roles.kind_of?(Array)
            roles.each do |role|
              add_role(box, role, name)
            end
          else
            add_role(box, roles, name)
          end
        end
      end
    end
  end
end
