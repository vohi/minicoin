# -*- mode: ruby -*-
# vi: set ft=ruby :

Vagrant.require_version ">= 2.2"

# Import YAML
require 'yaml'
require 'net/http'
require 'zip'

yaml = YAML.load_file(File.join(File.dirname(__FILE__), 'boxes.yml'))
$urls = yaml["urls"]
machines = yaml["machines"]

user_machine_file = File.join(ENV['HOME'], 'minicoin/boxes.yml');
if File.file?(user_machine_file)
  user_machines = YAML.load_file(user_machine_file)["machines"]
  user_machines.each do |user_machine|
    idx = machines.find_index {|m| m["name"] == user_machine["name"] }
    if !idx.nil?
      machines[idx].each do |key, value|
        if !user_machine[key].nil?
          machines[idx][key] = user_machine[key]
        end
      end
    else
      machines << user_machine
    end
  end
end

def fetch_file(uri, local)
  begin
    Net::HTTP.start(uri.host) do |http|
      req = Net::HTTP::Get.new(uri)
      http.request(req) do |response|
        case response
        when Net::HTTPSuccess then
          open("#{local}", "wb") do |file|
            response.read_body do |chunk|
              file.write(chunk)
            end
          end
        else
          puts "Error downloading: #{response.value}"
        end
      end
    end
  rescue
      puts "Error downloading #{uri}"
  end
end

def insert_disk(box, disk_filename, role_params)
  disk_data = YAML.load_file(disk_filename)
  disk_file = disk_data["file"]
  disk_archive = disk_data["archive"]

  if disk_archive.nil?
    disk_archive = disk_file
  end

  disk_cache = "#{__dir__}/.diskcache"
  if ["up", "provision", "reload"].include? ARGV[0]
    Dir.mkdir(disk_cache) unless Dir.exist?(disk_cache)

    if !File.file?("#{disk_cache}/#{disk_file}")
      if !File.file?("#{disk_cache}/#{disk_archive}")
        puts "Downloading '#{disk_archive}'..."
        $urls.each do |key, value|
          url = URI("#{value}/#{key}/#{disk_archive}")
          puts "Trying to download '#{url}'..."
          fetch_file(url, "#{disk_cache}/#{disk_archive}")
        end
      end
      if disk_archive.end_with?(".zip")
        puts "Extracting '#{disk_archive}'"
        Zip::File.open("#{disk_cache}/#{disk_archive}") do |zipfile|
          zipfile.extract("#{disk_file}", "#{disk_cache}/#{disk_file}")
        end
      end
    end
    if !File.file?("#{disk_cache}/#{disk_file}")
      puts "==> #{role}: ISO file '#{disk_file}' not available"
    else
      box.vm.provider "virtualbox" do |vb|
        storage_params = [
          "storageattach", :id,
          "--medium", "#{disk_cache}/#{disk_file}",
        ]

        disk_settings = disk_data["settings"] unless disk_data.nil?
        if disk_settings.nil?
          disk_settings = {}
        end

        # default settings, disks can override
        disk_settings["storagectl"] = "SATA" unless !disk_settings["storagectl"].nil?

        if disk_file.end_with?(".iso")
          disk_settings["port"] = "1" unless !disk_settings["port"].nil?
          disk_settings["type"] = "dvddrive" unless !disk_settings["type"].nil?
        elsif disk_file.end_with?(".vdi")
          disk_settings["port"] = "2" unless !disk_settings["port"].nil?
          disk_settings["type"] = "hdd" unless !disk_settings["type"].nil?
          disk_settings["mtype"] = "multiattach" unless !disk_settings["mtype"]
        end

        # boxes can override disk settings
        if role_params.is_a?(Hash)
          role_params.each do |key, value|
            disk_settings[key] = value
          end
        end

        disk_settings.each do |key, value|
          storage_params += ["--#{key}", "#{value}"]
        end
        vb.customize storage_params
      end
    end
  end
end

def add_role(box, role, name)
  role_params = role
  if role.is_a?(Hash)
    role = role["role"]
    role_params.delete("role")
    role_params.each do |key, value|
      if value.nil?
        continue
      end
      if value.is_a?(String) and matches = value.match(/\$([A-Z_]*)/)
        env_val = ENV[matches[1]]
        if env_val.nil?
          puts "==> #{name}: Environment variable '$#{matches[1]}' not set - skipping #{role}"
          return
        end
        role_params[key] = env_val
      end
    end
  end

  role_path = "#{__dir__}#{role_path}/roles/#{role}"
  activity = false
  if File.file?("#{role_path}/playbook.yml")
    box.vm.provision "ansible" do |ansible|
      ansible.playbook = "#{role_path}/playbook.yml"
      ansible.become = true unless box.vm.guest == :windows
    end
    activity = true
  elsif File.file?("#{role_path}/disk.yml")
    activity = true
    insert_disk(box, "#{role_path}/disk.yml", role_params)
  end

  # always check for a provisioning script
  script_ext = ".sh"
  upload_path = "/tmp/vagrant-shell"
  if box.vm.guest == :windows
    script_ext = ".cmd"
    if File.file?("#{role_path}/provision.ps1")
      script_ext = ".ps1"
    end
    upload_path = "c:\\Windows\\temp\\"
  end
  provisioning_file = "#{role_path}/provision#{script_ext}"
  if File.file?(provisioning_file)
    activity = true
    script_args = [role, name, ENV['USER']]
    if role_params.is_a?(Hash)
      role_params.each do |key, value|
        script_args += ["--#{key}"]
        script_args += ["#{value}"] unless value.nil?
      end
    end
    box.vm.provision "shell", name: "#{role}", path: "#{provisioning_file}",
      args: script_args,
      upload_path: upload_path,
      privileged: true
  end

  if ! activity
    puts "==> #{role}: Provisioning script at '#{provisioning_file}' not found!"
  else
    # check for pre-/post-provisioning script to run locally
    if File.file?("#{role_path}/pre-provision.sh")
      box.trigger.before [:up, :provision] do |trigger|
        trigger.name = "before #{role}"
        trigger.run = {
          path: "#{role_path}/pre-provision.sh",
          args: name
        }
      end
    end

    if File.file?("#{role_path}/post-provision.sh")
      box.trigger.after [:up, :provision] do |trigger|
        trigger.name = "after #{role}"
        trigger.run = {
          path: "#{role_path}/post-provision.sh",
          args: name
        }
      end
    end
  end
end

Vagrant.configure("2") do |config|
  if ARGV[0] == "up" and ARGV.length == 1
    puts "This is a multi-machine environment. The following machines are available:"
    puts
    machines.each do |machine|
      puts "- #{machine['name']}"
    end
    puts
    puts "Please, specify which machine(s) you want to bring up."
    exit
  end

  machines.each do |machine|
    config.vm.define machine["name"] do |box|
      name = machine["name"]
      machine_box = machine["box"]

      is_windows = (name.include? "windows") || (machine_box.include? "windows")
      is_mac = (name.include? "mac") || (machine_box.include? "mac")

      maker = machine_box.split(/\//).first
      source = $urls[maker]
      unless source.nil?
        box.vm.box_url = [
          "#{source}/#{machine_box}.box",
          "#{source}/#{machine_box}-base.box"
        ]
      end
      box.vm.box = machine_box
      box.vm.box_version = machine["box_version"] unless machine["box_version"].nil?
      if !is_windows
        box.vm.hostname = name
      end
      private_net = machine["private_net"]
      if private_net.nil?
        box.vm.network "private_network", type: "dhcp"
      elsif private_net != "disabled"
        box.vm.network "private_network", ip: "#{private_net}"
      end

      # VirtualBox specific settings
      box.vm.provider "virtualbox" do |vb|
        vb.memory = machine["memory"] unless machine["memory"].nil?
        vb.cpus = machine["cpus"] unless machine["cpus"].nil?
        vb.gui = machine["gui"] unless machine["gui"].nil?
        vb.customize ["modifyvm", :id, "--vram", machine["vram"]] unless machine["vram"].nil?
        vb.name = name
        if is_windows || is_mac # "Intel Pro/1000 MT Desktop" must be used on Windows and Mac
          vb.customize [
            "modifyvm", :id,
            "--nictype1", "82540EM"
          ]
        end

        vb.customize [
          "modifyvm", :id,
          "--clipboard", "bidirectional"
        ]
      end

      # Platform specific configurations
      guest_home = "/home/host"
      guest_filedir = ""

      if is_windows
        box.vm.guest = :windows
        guest_home = "/host"
        guest_filedir = "c:\\Users\\vagrant\\"

        # Test if winrm is available
        begin
          has_winrm = require 'winrm'
        rescue LoadError
          puts "==> #{name}: WinRM gem not installed, falling back to winssh!"
          puts "    #{name}: Shared folder support and file provisioning might fail"
        end

        if has_winrm
          box.vm.communicator = :winrm
          box.winrm.transport = :plaintext
          box.winrm.basic_auth_only = true
        else
          box.vm.communicator = :winssh
        end
      elsif is_mac
        guest_home = "/Users/host"
      else
      end

      # Allow overriding defaults
      box.vm.communicator = machine["communicator"] unless machine["communicator"].nil?

      if box.vm.communicator == :winssh
        box.winssh.insert_key = false # Replacing insecure key on Windows fails or takes forever
      end

      if machine["shared_folders"] == "disabled"
        box.vm.synced_folder ".", "/minicoin", disabled: true
      elsif is_mac
        box.vm.synced_folder ".", "/minicoin", type: "rsync", rsync__chown: false
      else
        box.vm.synced_folder "~", "#{guest_home}"
        box.vm.synced_folder ".", "/minicoin"
        if is_windows
          box.vm.provision "shell", inline: \
            'cmd /c "rd c:\\minicoin & rd c:\\host & rd c:\\Users\\host & ' \
            'mklink /D C:\\minicoin \\\\VBOXSRV\\minicoin & ' \
            'mklink /D C:\\host \\\\VBOXSRV\\host & ' \
            'mklink /J C:\\Users\\host C:\\host"'
        end
      end

      # Copying files to guest
      if !is_windows || box.vm.communicator == :winrm # file provisioning via winssh is broken
        box.vm.provision "file", source: "~/.gitconfig", destination: "#{guest_filedir}.gitconfig"
      end

      # Execution of provisioning script
      if ["up", "provision", "reload", "validate"].include? ARGV[0]
        roles = machine["roles"]
        unless roles.nil? or roles.empty?
          if roles.kind_of?(Array)
            roles.each do |role|
              add_role(box, role, name)
            end
          else
            add_role(box, roles, name)
          end
        end
      end
    end
  end
end
